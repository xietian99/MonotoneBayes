dt.stan$c_sq_shape = c_alpha
dt.stan$c_sq_scale = c_beta
model = rstan::sampling(stanmodels$RegHS, data = dt.stan, ...)
}
}
return(model)
}
example(source)
roxygen2::roxygenize(load_code = sourceDir)
roxygen2::roxygenize(load_code = sourceDir, clean = T)
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
roxygen2::roxygenize()
devtools::document()
.Last.error
remotes::install_github("xietian99/MonotoneBayes", ref = "master")
library(MonotoneBayes)
library(MonotoneBayes)
??`MonotoneBayes-package`
devtools::document()
devtools::document()
devtools::document()
example(source) #
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
roxygen2::roxygenize()
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
roxygen2::roxygenize()
devtools::document()
install.packages("../MonotoneBayes", repos = NULL, type = "source")
library(MonotoneBayes)
library(ggplot2)
library(reshape2)
library(dplyr)
generateData = function(N, L=10, ratio = 0.1){
# ratio means
data = matrix(0 ,nrow = N, ncol = 5)
colnames(data) = c("x","m1","m2", "m3", "L10")
data = as.data.frame(data)
data$x = seq(0,1,length.out = N)
data$L10 = data$x %/% (1/L) + 1
data$m1[1:(N/2)] = 0
data$m1[(N/2+1):N] = 1
data$m2 =
data$m3 = data$m1
ratio = ratio # 5%-10%
rind_m2 = sample(1:(N/2), size = ceiling(N/2*ratio))
rind_m3 = sample((N/2+1):N, size = ceiling(N/2*ratio))
data$m2[rind_m2] = 1
data$m3[rind_m3] = 0
return(data)
}
options(mc.cores = parallel::detectCores()) # for local use
N = 50
set.seed(699)
data = generateData(N)
# set hyper-parameter for regularized HS
c_sq_shape = 1
c_sq_scale = 1 * 4
tau0 = 1e-4
which_outcome = "m1"
L = 10
model.regHS = monotoneBayes(X = data[,"x"], Y = data[,which_outcome], prior = "Regularized HS",
L = L, tau0 = tau0, c_alpha = c_sq_shape, c_beta = c_sq_scale) # Running time: 4 chain 69s, 290s, 366s, 490s
model.orgHS = monotoneBayes(X = data[,"x"], Y = data[,which_outcome], prior = "Original HS",
L = L, tau0 = tau0)
# Check the posterior distribution of fitted model on Estimated Gamma and the IntergalAlpha
# Each outcome.XX store the posterior mean/median(50%), quantitles (0.1,0.25,0.75,0.9)
outcome.orgHS = sumStats(model.orgHS, ndigit = 3, orgHS = T)
outcome.regHS = sumStats(model.regHS, ndigit = 3)
View(model.regHS)
# Check the posterior distribution of fitted model on Estimated Gamma and the IntergalAlpha
# Each outcome.XX store the posterior mean/median(50%), quantitles (0.1,0.25,0.75,0.9)
outcome.orgHS = sumStats(model.orgHS, ndigit = 3, orgHS = T)
outcome.regHS = sumStats(model.regHS, ndigit = 3)
View(outcome.regHS)
View(outcome.orgHS)
plot(data$m1)
L
model.regHS.L25 = monotoneBayes(X = data[,"x"], Y = data[,which_outcome], prior = "Regularized HSp",
L = 25, tau0 = tau0, c_alpha = c_sq_shape, c_beta = c_sq_scale) # Running time: 4 chain 32s - 40s
outcome.regHS.L25 = sumStats(model.regHS.L25, ndigit = 3)
View(outcome.regHS.L25)
# Below the method can be posterior "mean" or "median", median seems perform terrible.
dt.outcome = data.frame("x" = (plotModel(model.orgHS, L = L, method = "mean")$FittedProb)$x,
"OrgHS" = (plotModel(model.orgHS, L = L, method = "mean")$FittedProb)$EstPr.Y,
"RegHS" = (plotModel(model.regHS, L = L, method = "mean")$FittedProb)$EstPr.Y,
"RegHS.L25" = (plotModel(model.regHS.L25, L = 25, method = "mean")$FittedProb)$EstPr.Y)
dt.outcome %>% melt(id.vars = "x") %>% ggplot() +
geom_line(aes(x = x, y = value, color = variable)) +
geom_point(data = data, aes(x = x, y = get(which_outcome)), alpha = 0.2) +
ylim(0,1) + ggtitle(paste("N=",N,", ",which_outcome,", Tau0=",tau0, sep = ""))
library(ggplot2)
library(reshape2)
library(dplyr)
dt.outcome %>% melt(id.vars = "x") %>% ggplot() +
geom_line(aes(x = x, y = value, color = variable)) +
geom_point(data = data, aes(x = x, y = get(which_outcome)), alpha = 0.2) +
ylim(0,1) + ggtitle(paste("N=",N,", ",which_outcome,", Tau0=",tau0, sep = ""))
library(ggplot2)
remove.packages("ggplot2")
library(ggplot2)
install.packages("ggplot2")
plot((plotModel(model.orgHS, L = L, method = "mean")$FittedProb)$EstPr.Y)
plot((plotModel(model.regHS, L = L, method = "mean")$FittedProb)$EstPr.Y)
plot((plotModel(model.regHS.L25, L = L, method = "mean")$FittedProb)$EstPr.Y)
plot((plotModel(model.regHS.L25, L = 25, method = "mean")$FittedProb)$EstPr.Y)
plot((plotModel(model.regHS, L = L, method = "mean")$FittedProb)$EstPr.Y)
plot((plotModel(model.regHS.L25, L = 25, method = "mean")$FittedProb)$EstPr.Y)
dt.outcome %>% melt(id.vars = "x") %>% ggplot() +
geom_line(aes(x = x, y = value, color = variable)) +
geom_point(data = data, ggplot::aes(x = x, y = get(which_outcome)), alpha = 0.2) +
ylim(0,1) + ggtitle(paste("N=",N,", ",which_outcome,", Tau0=",tau0, sep = ""))
?aes
??aes
save.image("../Outcome/preTest.RData")
?monotoneBayes
??monotoneBayes
pkgbuild::compile_dll()
pkgbuild::compile_dll()
devtools::document()
devtools::document()
devtools::document()
X = runif(50, 0, 1)
Y = rbinom(50)
Y = rbinom(50,1)
Y = rbinom(50,0.3)
Y = rbinom(50,1, 0.3)
Y
test = monotoneBayes(X = data[,"x"], Y = data[,which_outcome], prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 3, # 10s
L = 10, tau0_sq = 1e-2)
test = monotoneBayes(X = data[,"x"], Y = data[,which_outcome], prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 3, # 10s
L = 10, tau0_sq = 1e-2)
monotoneBayes = function(X, Y, L = 10, tau0_sq = 1e-2, nodes = seq(0,1,length.out = 10+1), Eq.Space = T,
c_sq = 10^2, fix = F,
c_alpha = 1, c_beta = 1 * 200, prior = "Regularized HS", ...){
N = length(Y)
if (Eq.Space == F) {
#nodes = (nodes - min(X))/(max(X) - min(X))
#X = (X - min(X))/(max(X) - min(X))
data.J = rowSums(outer(X, nodes, "-")>=0)
data.J[data.J>=L] = L
data.W = nodes[2:(L+1)]- nodes[1:L]
} else {
nodes = seq(0, 1, length.out = L+1)
#X = (X - min(X))/(max(X) - min(X))
data.J = X %/% (1/L) + 1
data.W = 1/L
}
dt.stan = list(Y=Y, X = X, J = data.J,  W = data.W, nodes = nodes, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1,
tau0_sq = tau0_sq)
if (prior == "Original HS"){
model = rstan::sampling(stanmodels$OrgHS, data = dt.stan, ...)
} else if (prior == "Laplacian"){
model = rstan::sampling(stanmodels$Laplacian, data = dt.stan, ...)
} else if (prior == "Gaussian"){
model = rstan::sampling(stanmodels$Gaussian, data = dt.stan, ...)
} else {
if (fix == T) {
dt.stan$c_sq = c_sq
model = rstan::sampling(stanmodels$RegHSfix, data = dt.stan, ...)
} else {
dt.stan$c_sq_shape = c_alpha
dt.stan$c_sq_scale = c_beta
model = rstan::sampling(stanmodels$RegHS, data = dt.stan, ...)
}
}
return(model)
}
stan_model()
install.packages("../MonotoneBayes", repos = NULL, type = "source")
test = monotoneBayes(X = data[,"x"], Y = data[,which_outcome], prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 3, # 10s
L = 10, tau0_sq = 1e-2)
test = monotoneBayes(X = X, Y = Y, prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 1, # 10s
L = 10, tau0_sq = 1e-2)
library(MonotoneBayes)
test = monotoneBayes(X = X, Y = Y, prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 1, # 10s
L = 10, tau0_sq = 1e-2)
pkgbuild::compile_dll()
monotoneBayes(X = X, Y = Y, prior = "Regularized HS",
+                      fix = T, c_sq = 1e5, chain = 1, # 10s
monotoneBayes(X = X, Y = Y, prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 1, # 10s
L = 10, tau0_sq = 1e-2)
devtools::document()
rm(list = c("monotoneBayes"))
devtools::document()
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
roxygen2::roxygenize()
install.packages("../MonotoneBayes", repos = NULL, type = "source")
library(MonotoneBayes)
stanmodels$RegHSfix
test = monotoneBayes(X = X, Y = Y, prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 1, # 10s
L = 10, tau0_sq = 1e-2)
install.packages("../MonotoneBayes", repos = NULL, type = "source")
test = monotoneBayes(X = X, Y = Y, prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 1, # 10s
L = 10, tau0_sq = 1e-2)
library(MonotoneBayes)
test = monotoneBayes(X = X, Y = Y, prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 1, # 10s
L = 10, tau0_sq = 1e-2)
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
roxygen2::roxygenize()
library(MonotoneBayes)
library(MonotoneBayes)
library(MonotoneBayes)
test = monotoneBayes(X = X, Y = Y, prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 1, # 10s
L = 10, tau0_sq = 1e-2)
test = monotoneBayes(X = X, Y = Y, prior = "Regularized HS",
fix = T, c_sq = 1e5, chain = 1, # 10s
L = 10, tau0_sq = 1e-2)
install.packages("../MonotoneBayes", repos = NULL, type = "source")
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
roxygen2::roxygenize()
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
roxygen2::roxygenize()
try(roxygen2::roxygenize(load_code = sourceDir), silent = TRUE)
roxygen2::roxygenize()
try(roxygen2::roxygenize(load_code = rstantools_load_code), silent = TRUE)
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
predictCov = function(model, method = "mean", grid.eq = T, node.t, newX, newZ, returnCI = T){
rs.sampler = rstan::extract(model, pars = c("alpha", "gamma", "Gamma","denominator","cumsum_alphaW"))
L = ncol(rs.sampler$alpha)
M.samples = nrow(rs.sampler$alpha)
if (grid.eq == T){
node.t = seq(0,1, length.out = L + 1)
}
x.J = rowSums(outer(newX, node.t, "-")>=0)
x.J[x.J > L] = L # Extrapolation for new X greater than the maximum X for model fitting
x.J[x.J == 0] = 1  # Extrapolation for new X less than the minimum X for model fitting
y = matrix(rep(newX, each = M.samples), nrow = M.samples, ncol = length(newX))
for (i in 1:length(newX)){
j = x.J[i]
if (j == 1){
y[,i] = ( newX[i] * rs.sampler$alpha[,1] + 1 ) / rs.sampler$denominator
} else {
y[,i] = ( rs.sampler$cumsum_alphaW[,j-1] + (x.N[i]-node.t[j-1]) * rs.sampler$alpha[,j] + 1  ) / rs.sampler$denominator
}
y[,i] = logit(y[,i])
y[,i] = y[,i] + newZ[i] * rs.sampler$Gamma
y[,i] = expit(y[,i])
}
y.mean = colMeans(y)
y.CI = apply(y, 1, quantile,probs = c(0.5, 0.025, 0.975))
y.all <-list("mean" = y.mean, "median" = y.CI[1,],
"l.ci" = y.CI[2,], "u.ci" = y.CI[3,])
return(y.all)
}
roxygen2::roxygenize()
rm(list = c("predictCov"))
roxygen2::roxygenize()
devtools::clean_dll
devtools::clean_dll()
pkgbuild::compile_dll()
roxygen2::roxygenize()
monotoneBayes = function(X, Y, Z, L = 10, tau0_sq = 1e-2, nodes = seq(0,1,length.out = 10+1), Eq.Space = T,
c_sq = 10^2, fix = F,
c_alpha = 1, c_beta = 1 * 200, prior = "Regularized HS", ...){
N = length(Y)
if (Eq.Space == F) {
#nodes = (nodes - min(X))/(max(X) - min(X))
#X = (X - min(X))/(max(X) - min(X))
data.J = rowSums(outer(X, nodes, "-")>=0)
data.J[data.J>=L] = L
data.W = nodes[2:(L+1)]- nodes[1:L]
} else {
nodes = seq(0, 1, length.out = L+1)
#X = (X - min(X))/(max(X) - min(X))
data.J = X %/% (1/L) + 1
data.W = rep(1/L,L)
}
if (is.null(Z)){
dt.stan = list(Y=Y, X = X, J = data.J,  W = data.W, nodes = nodes, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1,
tau0_sq = tau0_sq)
if (prior == "Original HS"){
model = rstan::sampling(stanmodels$OrgHS, data = dt.stan, ...)
} else if (prior == "Laplacian"){
model = rstan::sampling(stanmodels$Laplacian, data = dt.stan, ...)
} else if (prior == "Gaussian"){
model = rstan::sampling(stanmodels$Gaussian, data = dt.stan, ...)
} else {
if (fix == T) {
dt.stan$c_sq = c_sq
model = rstan::sampling(stanmodels$RegHSfix, data = dt.stan, ...)
} else {
dt.stan$c_sq_shape = c_alpha
dt.stan$c_sq_scale = c_beta
model = rstan::sampling(stanmodels$RegHS, data = dt.stan, ...)
}
}
} else {
dt.stan = list(Y=Y, X = X, Z=Z, J = data.J,  W = data.W, nodes = nodes, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1,
tau0_sq = tau0_sq)
model = rstan::sampling(stanmodels$CovModel_HS, data = dt.stan, ...)
}
return(model)
}
fD.x1 = function(x){
y = x
y[x<=0.4] = 0.2
y[x>0.4 & x<0.7] = x[x>0.4 & x<0.7] * 2 - 0.6
y[x>=0.7]  = 0.8
return(y)
}
logit = function(x){
return(log(x/(1-x)))
}
expit = function(x){
return(exp(x)/(1+exp(x)))
}
fD.x0 = function(x){
y = fD.x1(x)
y = expit(logit(y) - 2)
return(y)
}
x.seq = seq(0,1,length.out = 200)
plot(fD.x1(x.seq), ylim = c(0,1))
plot(fD.x0(x.seq), ylim = c(0,1))
N = 200
data = matrix(0, nrow = N, ncol = 1+1+1+1)
colnames(data) = c("X","Z","trueP","Y")
set.seed(38938)
data[,"X"] = runif(N, 0, 1)
data[,"Z"] = sample(c(0,1), size = N, replace = T)
data[,1] = (data[,1] - min(data[,1])) / (max(data[,1]) - min(data[,1]))
data[which(data[,"Z"]==1),"trueP"] = fD.x1(data[which(data[,"Z"]==1),"X"])
data[which(data[,"Z"]==0),"trueP"] = fD.x0(data[which(data[,"Z"]==0),"X"])
data[,"Y"] = rbinom(N, size = 1, prob = data[,"trueP"])
#data.t = quantile(data$x,  seq(0,1,length.out = L+1))
L = 30
data.t = seq(0,1,length.out = L+1)
data.J = rowSums(outer(data[,"X"], data.t, "-")>=0)
data.J[data.J>=L] = L # change x_max with index L
data.W = data.t[2:(L+1)]-data.t[1:L]
model.hs = monotoneBayes(X = data[,"X"], Y = data[, "Y"],Z = data[,"Z"],
J = data.J,  W = data.W, nodes = data.t, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1,
c_sq_shape = 1, c_sq_scale = 1e5,
tau0_sq = 1e-2)
data.J
monotoneBayes = function(X, Y, Z, L = 10, tau0_sq = 1e-2, nodes = seq(0,1,length.out = 10+1), Eq.Space = T,
c_sq = 10^2, fix = F,
c_alpha = 1, c_beta = 1 * 200, prior = "Regularized HS", ...){
N = length(Y)
if (Eq.Space == F) {
#nodes = (nodes - min(X))/(max(X) - min(X))
#X = (X - min(X))/(max(X) - min(X))
data.J = rowSums(outer(X, nodes, "-")>=0)
data.J[data.J>=L] = L
data.W = nodes[2:(L+1)]- nodes[1:L]
} else {
nodes = seq(0, 1, length.out = L+1)
#X = (X - min(X))/(max(X) - min(X))
data.J = X %/% (1/L) + 1
data.J[data.J>=L] = L
data.W = rep(1/L,L)
}
if (is.null(Z)){
dt.stan = list(Y=Y, X = X, J = data.J,  W = data.W, nodes = nodes, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1,
tau0_sq = tau0_sq)
if (prior == "Original HS"){
model = rstan::sampling(stanmodels$OrgHS, data = dt.stan, ...)
} else if (prior == "Laplacian"){
model = rstan::sampling(stanmodels$Laplacian, data = dt.stan, ...)
} else if (prior == "Gaussian"){
model = rstan::sampling(stanmodels$Gaussian, data = dt.stan, ...)
} else {
if (fix == T) {
dt.stan$c_sq = c_sq
model = rstan::sampling(stanmodels$RegHSfix, data = dt.stan, ...)
} else {
dt.stan$c_sq_shape = c_alpha
dt.stan$c_sq_scale = c_beta
model = rstan::sampling(stanmodels$RegHS, data = dt.stan, ...)
}
}
} else {
dt.stan = list(Y=Y, X = X, Z=Z, J = data.J,  W = data.W, nodes = nodes, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1,
tau0_sq = tau0_sq)
model = rstan::sampling(stanmodels$CovModel_HS, data = dt.stan, ...)
}
return(model)
}
model.hs = monotoneBayes(X = data[,"X"], Y = data[, "Y"],Z = data[,"Z"],
J = data.J,  W = data.W, nodes = data.t, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1,
c_sq_shape = 1, c_sq_scale = 1e5,
tau0_sq = 1e-2)
data[,"X"]
Z = data[,"Z"]
Z
pkgbuild::compile_dll()
monotoneBayes = function(X, Y, Z, L = 10, tau0_sq = 1e-2, nodes = seq(0,1,length.out = 10+1), Eq.Space = T,
c_sq = 10^2, fix = F,
c_alpha = 1, c_beta = 1 * 200, prior = "Regularized HS", ...){
N = length(Y)
if (Eq.Space == F) {
#nodes = (nodes - min(X))/(max(X) - min(X))
#X = (X - min(X))/(max(X) - min(X))
data.J = rowSums(outer(X, nodes, "-")>=0)
data.J[data.J>=L] = L
data.W = nodes[2:(L+1)]- nodes[1:L]
} else {
nodes = seq(0, 1, length.out = L+1)
#X = (X - min(X))/(max(X) - min(X))
data.J = X %/% (1/L) + 1
data.J[data.J>=L] = L
data.W = rep(1/L,L)
}
if (is.null(Z)){
dt.stan = list(Y=Y, X = X, J = data.J,  W = data.W, nodes = nodes, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1,
tau0_sq = tau0_sq)
if (prior == "Original HS"){
model = rstan::sampling(stanmodels$OrgHS, data = dt.stan, ...)
} else if (prior == "Laplacian"){
model = rstan::sampling(stanmodels$Laplacian, data = dt.stan, ...)
} else if (prior == "Gaussian"){
model = rstan::sampling(stanmodels$Gaussian, data = dt.stan, ...)
} else {
if (fix == T) {
dt.stan$c_sq = c_sq
model = rstan::sampling(stanmodels$RegHSfix, data = dt.stan, ...)
} else {
dt.stan$c_sq_shape = c_alpha
dt.stan$c_sq_scale = c_beta
model = rstan::sampling(stanmodels$RegHS, data = dt.stan, ...)
}
}
} else {
dt.stan = list(Y=Y, X = X, Z=Z, J = data.J,  W = data.W, nodes = nodes, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1, c_sq_shape = c_alpha, c_sq_scale = c_beta,
tau0_sq = tau0_sq)
model = rstan::sampling(stanmodels$CovModel_HS, data = dt.stan, ...)
}
return(model)
}
model.hs = monotoneBayes(X = data[,"X"], Y = data[, "Y"],Z = data[,"Z"],
J = data.J,  W = data.W, nodes = data.t, L=L, N=N,
local_dof_stan = 1,
global_dof_stan = 1,
c_alpha = 1, c_beta = 1e5,
tau0_sq = 1e-2)
data.t
model.hs = monotoneBayes(X = data[,"X"], Y = data[, "Y"],Z = data[,"Z"],
Eq.Space = T, L=L,
local_dof_stan = 1,
global_dof_stan = 1,
c_alpha = 1, c_beta = 1e3,
tau0_sq = 1e-2)
model.hs = monotoneBayes(X = data[,"X"], Y = data[, "Y"], Z = data[,"Z"],
Eq.Space = T, L=L,
c_alpha = 1, c_beta = 1e3,
tau0_sq = 1e-2)
install.packages("../MonotoneBayes", repos = NULL, type = "source")
outcome.hs = predictCov(model.hs, grid.eq = T, newX = data[,"X"], newZ = data[,"Z"], returnCI = T)
install.packages("../MonotoneBayes", repos = NULL, type = "source")
outcome.hs = predictCov(model.hs, grid.eq = T, newX = data[,"X"], newZ = data[,"Z"], returnCI = T)
install.packages("../MonotoneBayes", repos = NULL, type = "source")
library(MonotoneBayes)
outcome.hs = predictCov(model.hs, grid.eq = T, newX = data[,"X"], newZ = data[,"Z"], returnCI = T)
pkgbuild::compile_dll()
install.packages("../MonotoneBayes", repos = NULL, type = "source")
try(roxygen2::roxygenize(load_code = rstantools_load_code), silent = TRUE)
roxygen2::roxygenize()
install.packages("../MonotoneBayes", repos = NULL, type = "source")
pkgbuild::compile_dll()
roxygen2::roxygenize()
roxygen2::roxygenize()
pkg_build::compile_all()
pkgbuild::compile_dll()
roxygen2::roxygenize()
install.packages("../MonotoneBayes", repos = NULL, type = "source")
install.packages("../MonotoneBayes", repos = NULL, type = "source")
library(brms)
?brms
?brm
2.5^2]
2.5^2
?stan
try(roxygen2::roxygenize(load_code = rstantools_load_code), silent = TRUE)
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
2178.56 * 0.65
1416+200
1616/0.65
